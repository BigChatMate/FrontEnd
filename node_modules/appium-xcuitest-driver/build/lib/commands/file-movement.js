"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.commands = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _lodash = _interopRequireDefault(require("lodash"));

var _appiumSupport = require("appium-support");

var _path = _interopRequireDefault(require("path"));

var _appiumIosDriver = require("appium-ios-driver");

var _logger = _interopRequireDefault(require("../logger"));

var _teen_process = require("teen_process");

var _nodeSimctl = require("node-simctl");

const CONTAINER_PATH_MARKER = '@';
const CONTAINER_PATH_PATTERN = new RegExp(`^${CONTAINER_PATH_MARKER}([^/]+)/(.+)`);
const CONTAINER_TYPE_SEPARATOR = ':';
let commands = _appiumIosDriver.iosCommands.file;
exports.commands = commands;

function verifyIFusePresence() {
  return _verifyIFusePresence.apply(this, arguments);
}

function _verifyIFusePresence() {
  _verifyIFusePresence = (0, _asyncToGenerator2.default)(function* () {
    if (!(yield _appiumSupport.fs.which('ifuse'))) {
      _logger.default.errorAndThrow(`'ifuse' tool is required to be installed on the machine. ` + `Install it using 'brew cask install osxfuse && brew install ifuse' or check ` + `if it is available in PATH environment variable if the tool is already installed. ` + `Current PATH value: ${process.env.PATH}`);
    }
  });
  return _verifyIFusePresence.apply(this, arguments);
}

function mountDevice(_x, _x2) {
  return _mountDevice.apply(this, arguments);
}

function _mountDevice() {
  _mountDevice = (0, _asyncToGenerator2.default)(function* (device, iFuseArgs) {
    _logger.default.debug(`Starting ifuse with args '${iFuseArgs}'...`);

    try {
      yield (0, _teen_process.exec)('ifuse', iFuseArgs);
    } catch (e) {
      _logger.default.errorAndThrow(`Cannot mount the media folder of the device with UDID ${device.udid}. ` + `Make sure osxfuse plugin has necessary permissions in System Preferences->Security & Privacy. ` + `Error code: ${e.code}; stderr output: ${e.stderr}`);
    }
  });
  return _mountDevice.apply(this, arguments);
}

function verifyIsSubPath(originalPath, root) {
  const normalizedRoot = _path.default.normalize(root);

  const normalizedPath = _path.default.normalize(_path.default.dirname(originalPath));

  if (!normalizedPath.startsWith(normalizedRoot)) {
    _logger.default.errorAndThrow(`'${normalizedPath}' is expected to be a subpath of '${normalizedRoot}'`);
  }
}

function parseContainerPath(_x3, _x4) {
  return _parseContainerPath.apply(this, arguments);
}

function _parseContainerPath() {
  _parseContainerPath = (0, _asyncToGenerator2.default)(function* (remotePath, containerRootSupplier) {
    const match = CONTAINER_PATH_PATTERN.exec(remotePath);

    if (!match) {
      _logger.default.errorAndThrow(`It is expected that package identifier ` + `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` + `relative path with a single slash. '${remotePath}' is given instead`);
    }

    let _match = (0, _slicedToArray2.default)(match, 3),
        bundleId = _match[1],
        relativePath = _match[2];

    let containerType = null;
    const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);

    if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {
      containerType = bundleId.substring(typeSeparatorPos + 1);

      _logger.default.debug(`Parsed container type: ${containerType}`);

      bundleId = bundleId.substring(0, typeSeparatorPos);
    }

    const containerRoot = _lodash.default.isFunction(containerRootSupplier) ? yield containerRootSupplier(bundleId, containerType) : containerRootSupplier;

    const resultPath = _path.default.posix.resolve(containerRoot, relativePath);

    verifyIsSubPath(resultPath, containerRoot);
    return [bundleId, resultPath];
  });
  return _parseContainerPath.apply(this, arguments);
}

function pushFileToSimulator(_x5, _x6, _x7) {
  return _pushFileToSimulator.apply(this, arguments);
}

function _pushFileToSimulator() {
  _pushFileToSimulator = (0, _asyncToGenerator2.default)(function* (device, remotePath, base64Data) {
    const buffer = Buffer.from(base64Data, 'base64');

    if (CONTAINER_PATH_PATTERN.test(remotePath)) {
      const _ref6 = yield parseContainerPath(remotePath, function () {
        var _ref8 = (0, _asyncToGenerator2.default)(function* (appBundle, containerType) {
          return yield (0, _nodeSimctl.getAppContainer)(device.udid, appBundle, null, containerType);
        });

        return function (_x22, _x23) {
          return _ref8.apply(this, arguments);
        };
      }()),
            _ref7 = (0, _slicedToArray2.default)(_ref6, 2),
            bundleId = _ref7[0],
            dstPath = _ref7[1];

      _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will put the data into '${dstPath}'`);

      if (!(yield _appiumSupport.fs.exists(_path.default.dirname(dstPath)))) {
        _logger.default.debug(`The destination folder '${_path.default.dirname(dstPath)}' does not exist. Creating...`);

        yield (0, _appiumSupport.mkdirp)(_path.default.dirname(dstPath));
      }

      yield _appiumSupport.fs.writeFile(dstPath, buffer);
      return;
    }

    const dstFolder = yield _appiumSupport.tempDir.openDir();

    const dstPath = _path.default.resolve(dstFolder, _path.default.basename(remotePath));

    try {
      yield _appiumSupport.fs.writeFile(dstPath, buffer);
      yield (0, _nodeSimctl.addMedia)(device.udid, dstPath);
    } finally {
      yield _appiumSupport.fs.rimraf(dstFolder);
    }
  });
  return _pushFileToSimulator.apply(this, arguments);
}

function pushFileToRealDevice(_x8, _x9, _x10) {
  return _pushFileToRealDevice.apply(this, arguments);
}

function _pushFileToRealDevice() {
  _pushFileToRealDevice = (0, _asyncToGenerator2.default)(function* (device, remotePath, base64Data) {
    yield verifyIFusePresence();
    const mntRoot = yield _appiumSupport.tempDir.openDir();
    let isUnmountSuccessful = true;

    try {
      let dstPath = _path.default.resolve(mntRoot, remotePath);

      let ifuseArgs = ['-u', device.udid, mntRoot];

      if (CONTAINER_PATH_PATTERN.test(remotePath)) {
        const _ref9 = yield parseContainerPath(remotePath, mntRoot),
              _ref10 = (0, _slicedToArray2.default)(_ref9, 2),
              bundleId = _ref10[0],
              pathInContainer = _ref10[1];

        dstPath = pathInContainer;

        _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will put the data into '${dstPath}'`);

        ifuseArgs = ['-u', device.udid, '--container', bundleId, mntRoot];
      } else {
        verifyIsSubPath(dstPath, mntRoot);
      }

      yield mountDevice(device, ifuseArgs);
      isUnmountSuccessful = false;

      try {
        if (!(yield _appiumSupport.fs.exists(_path.default.dirname(dstPath)))) {
          _logger.default.debug(`The destination folder '${_path.default.dirname(dstPath)}' does not exist. Creating...`);

          yield (0, _appiumSupport.mkdirp)(_path.default.dirname(dstPath));
        }

        yield _appiumSupport.fs.writeFile(dstPath, Buffer.from(base64Data, 'base64'));
      } finally {
        yield (0, _teen_process.exec)('umount', [mntRoot]);
        isUnmountSuccessful = true;
      }
    } finally {
      if (isUnmountSuccessful) {
        yield _appiumSupport.fs.rimraf(mntRoot);
      } else {
        _logger.default.warn(`Umount has failed, so not removing '${mntRoot}'`);
      }
    }
  });
  return _pushFileToRealDevice.apply(this, arguments);
}

function pullFromSimulator(_x11, _x12, _x13) {
  return _pullFromSimulator.apply(this, arguments);
}

function _pullFromSimulator() {
  _pullFromSimulator = (0, _asyncToGenerator2.default)(function* (device, remotePath, isFile) {
    let pathOnServer;

    if (CONTAINER_PATH_PATTERN.test(remotePath)) {
      const _ref11 = yield parseContainerPath(remotePath, function () {
        var _ref13 = (0, _asyncToGenerator2.default)(function* (appBundle, containerType) {
          return yield (0, _nodeSimctl.getAppContainer)(device.udid, appBundle, null, containerType);
        });

        return function (_x24, _x25) {
          return _ref13.apply(this, arguments);
        };
      }()),
            _ref12 = (0, _slicedToArray2.default)(_ref11, 2),
            bundleId = _ref12[0],
            dstPath = _ref12[1];

      _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will get the data from '${dstPath}'`);

      pathOnServer = dstPath;
    } else {
      const simRoot = device.getDir();
      pathOnServer = _path.default.posix.join(simRoot, remotePath);
      verifyIsSubPath(pathOnServer, simRoot);

      _logger.default.info(`Got the full item path: ${pathOnServer}`);
    }

    if (!(yield _appiumSupport.fs.exists(pathOnServer))) {
      _logger.default.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${pathOnServer}' does not exist`);
    }

    const buffer = isFile ? yield _appiumSupport.fs.readFile(pathOnServer) : yield _appiumSupport.zip.toInMemoryZip(pathOnServer);
    return Buffer.from(buffer).toString('base64');
  });
  return _pullFromSimulator.apply(this, arguments);
}

function pullFromRealDevice(_x14, _x15, _x16) {
  return _pullFromRealDevice.apply(this, arguments);
}

function _pullFromRealDevice() {
  _pullFromRealDevice = (0, _asyncToGenerator2.default)(function* (device, remotePath, isFile) {
    yield verifyIFusePresence();
    const mntRoot = yield _appiumSupport.tempDir.openDir();
    let isUnmountSuccessful = true;

    try {
      let dstPath = _path.default.resolve(mntRoot, remotePath);

      let ifuseArgs = ['-u', device.udid, mntRoot];

      if (CONTAINER_PATH_PATTERN.test(remotePath)) {
        const _ref14 = yield parseContainerPath(remotePath, mntRoot),
              _ref15 = (0, _slicedToArray2.default)(_ref14, 2),
              bundleId = _ref15[0],
              pathInContainer = _ref15[1];

        dstPath = pathInContainer;

        _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will get the data from '${dstPath}'`);

        ifuseArgs = ['-u', device.udid, '--container', bundleId, mntRoot];
      } else {
        verifyIsSubPath(dstPath, mntRoot);
      }

      yield mountDevice(device, ifuseArgs);
      isUnmountSuccessful = false;

      try {
        if (!(yield _appiumSupport.fs.exists(dstPath))) {
          _logger.default.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${dstPath}' does not exist`);
        }

        const buffer = isFile ? yield _appiumSupport.fs.readFile(dstPath) : yield _appiumSupport.zip.toInMemoryZip(dstPath);
        return Buffer.from(buffer).toString('base64');
      } finally {
        yield (0, _teen_process.exec)('umount', [mntRoot]);
        isUnmountSuccessful = true;
      }
    } finally {
      if (isUnmountSuccessful) {
        yield _appiumSupport.fs.rimraf(mntRoot);
      } else {
        _logger.default.warn(`Umount has failed, so not removing '${mntRoot}'`);
      }
    }
  });
  return _pullFromRealDevice.apply(this, arguments);
}

commands.pushFile = function () {
  var _ref = (0, _asyncToGenerator2.default)(function* (remotePath, base64Data) {
    if (remotePath.endsWith('/')) {
      _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
    }

    if (_lodash.default.isArray(base64Data)) {
      base64Data = Buffer.from(base64Data).toString('utf8');
    }

    return this.isSimulator() ? yield pushFileToSimulator(this.opts.device, remotePath, base64Data) : yield pushFileToRealDevice(this.opts.device, remotePath, base64Data);
  });

  return function (_x17, _x18) {
    return _ref.apply(this, arguments);
  };
}();

commands.pullFile = function () {
  var _ref2 = (0, _asyncToGenerator2.default)(function* (remotePath) {
    if (remotePath.endsWith('/')) {
      _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
    }

    return this.isSimulator() ? yield pullFromSimulator(this.opts.device, remotePath, true) : yield pullFromRealDevice(this.opts.device, remotePath, true);
  });

  return function (_x19) {
    return _ref2.apply(this, arguments);
  };
}();

commands.getSimFileFullPath = function () {
  var _ref3 = (0, _asyncToGenerator2.default)(function* (remotePath) {
    let basePath = this.opts.device.getDir();
    let appName = null;

    if (this.opts.app) {
      let appNameRegex = new RegExp(`\\${_path.default.sep}([\\w-]+\\.app)`);
      let appNameMatches = appNameRegex.exec(this.opts.app);

      if (appNameMatches) {
        appName = appNameMatches[1];
      }
    }

    if (_appiumSupport.system.isWindows()) {
      if (remotePath.indexof('://') === 1) {
        remotePath = remotePath.slice(4);
      }
    } else {
      if (remotePath.indexOf('/') === 0) {
        remotePath = remotePath.slice(1);
      }
    }

    if (remotePath.indexOf(appName) === 0) {
      let findPath = basePath;

      if (this.opts.platformVersion >= 8) {
        findPath = _path.default.resolve(basePath, 'Containers', 'Bundle');
      }

      findPath = findPath.replace(/\s/g, '\\ ');

      let _ref4 = yield (0, _teen_process.exec)('find', [findPath, '-name', appName]),
          stdout = _ref4.stdout;

      let appRoot = stdout.replace(/\n$/, '');
      let subPath = remotePath.substring(appName.length + 1);

      let fullPath = _path.default.resolve(appRoot, subPath);

      _logger.default.debug(`Finding app-relative file: '${fullPath}'`);

      return fullPath;
    } else {
      let fullPath = _path.default.resolve(basePath, remotePath);

      _logger.default.debug(`Finding sim-relative file: ${fullPath}`);

      return fullPath;
    }
  });

  return function (_x20) {
    return _ref3.apply(this, arguments);
  };
}();

commands.pullFolder = function () {
  var _ref5 = (0, _asyncToGenerator2.default)(function* (remotePath) {
    if (!remotePath.endsWith('/')) {
      remotePath = `${remotePath}/`;
    }

    return this.isSimulator() ? yield pullFromSimulator(this.opts.device, remotePath, false) : yield pullFromRealDevice(this.opts.device, remotePath, false);
  });

  return function (_x21) {
    return _ref5.apply(this, arguments);
  };
}();

var _default = commands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIl0sIm5hbWVzIjpbIkNPTlRBSU5FUl9QQVRIX01BUktFUiIsIkNPTlRBSU5FUl9QQVRIX1BBVFRFUk4iLCJSZWdFeHAiLCJDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IiLCJjb21tYW5kcyIsImlvc0NvbW1hbmRzIiwiZmlsZSIsInZlcmlmeUlGdXNlUHJlc2VuY2UiLCJmcyIsIndoaWNoIiwibG9nIiwiZXJyb3JBbmRUaHJvdyIsInByb2Nlc3MiLCJlbnYiLCJQQVRIIiwibW91bnREZXZpY2UiLCJkZXZpY2UiLCJpRnVzZUFyZ3MiLCJkZWJ1ZyIsImUiLCJ1ZGlkIiwiY29kZSIsInN0ZGVyciIsInZlcmlmeUlzU3ViUGF0aCIsIm9yaWdpbmFsUGF0aCIsInJvb3QiLCJub3JtYWxpemVkUm9vdCIsInBhdGgiLCJub3JtYWxpemUiLCJub3JtYWxpemVkUGF0aCIsImRpcm5hbWUiLCJzdGFydHNXaXRoIiwicGFyc2VDb250YWluZXJQYXRoIiwicmVtb3RlUGF0aCIsImNvbnRhaW5lclJvb3RTdXBwbGllciIsIm1hdGNoIiwiZXhlYyIsImJ1bmRsZUlkIiwicmVsYXRpdmVQYXRoIiwiY29udGFpbmVyVHlwZSIsInR5cGVTZXBhcmF0b3JQb3MiLCJpbmRleE9mIiwibGVuZ3RoIiwic3Vic3RyaW5nIiwiY29udGFpbmVyUm9vdCIsIl8iLCJpc0Z1bmN0aW9uIiwicmVzdWx0UGF0aCIsInBvc2l4IiwicmVzb2x2ZSIsInB1c2hGaWxlVG9TaW11bGF0b3IiLCJiYXNlNjREYXRhIiwiYnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsInRlc3QiLCJhcHBCdW5kbGUiLCJkc3RQYXRoIiwiaW5mbyIsImV4aXN0cyIsIndyaXRlRmlsZSIsImRzdEZvbGRlciIsInRlbXBEaXIiLCJvcGVuRGlyIiwiYmFzZW5hbWUiLCJyaW1yYWYiLCJwdXNoRmlsZVRvUmVhbERldmljZSIsIm1udFJvb3QiLCJpc1VubW91bnRTdWNjZXNzZnVsIiwiaWZ1c2VBcmdzIiwicGF0aEluQ29udGFpbmVyIiwid2FybiIsInB1bGxGcm9tU2ltdWxhdG9yIiwiaXNGaWxlIiwicGF0aE9uU2VydmVyIiwic2ltUm9vdCIsImdldERpciIsImpvaW4iLCJyZWFkRmlsZSIsInppcCIsInRvSW5NZW1vcnlaaXAiLCJ0b1N0cmluZyIsInB1bGxGcm9tUmVhbERldmljZSIsInB1c2hGaWxlIiwiZW5kc1dpdGgiLCJpc0FycmF5IiwiaXNTaW11bGF0b3IiLCJvcHRzIiwicHVsbEZpbGUiLCJnZXRTaW1GaWxlRnVsbFBhdGgiLCJiYXNlUGF0aCIsImFwcE5hbWUiLCJhcHAiLCJhcHBOYW1lUmVnZXgiLCJzZXAiLCJhcHBOYW1lTWF0Y2hlcyIsInN5c3RlbSIsImlzV2luZG93cyIsImluZGV4b2YiLCJzbGljZSIsImZpbmRQYXRoIiwicGxhdGZvcm1WZXJzaW9uIiwicmVwbGFjZSIsInN0ZG91dCIsImFwcFJvb3QiLCJzdWJQYXRoIiwiZnVsbFBhdGgiLCJwdWxsRm9sZGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsTUFBTUEscUJBQXFCLEdBQUcsR0FBOUI7QUFFQSxNQUFNQyxzQkFBc0IsR0FBRyxJQUFJQyxNQUFKLENBQVksSUFBR0YscUJBQXNCLGNBQXJDLENBQS9CO0FBQ0EsTUFBTUcsd0JBQXdCLEdBQUcsR0FBakM7QUFHQSxJQUFJQyxRQUFRLEdBQUdDLDZCQUFZQyxJQUEzQjs7O1NBRWVDLG1COzs7Ozt5REFBZixhQUFzQztBQUNwQyxRQUFJLFFBQU9DLGtCQUFHQyxLQUFILENBQVMsT0FBVCxDQUFQLENBQUosRUFBOEI7QUFDNUJDLHNCQUFJQyxhQUFKLENBQW1CLDJEQUFELEdBQ0MsOEVBREQsR0FFQyxvRkFGRCxHQUdDLHVCQUFzQkMsT0FBTyxDQUFDQyxHQUFSLENBQVlDLElBQUssRUFIMUQ7QUFJRDtBQUNGLEc7Ozs7U0FFY0MsVzs7Ozs7aURBQWYsV0FBNEJD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RCxRQUFYLENBQW9CLEdBQXBCLENBQUwsRUFBK0I7QUFDN0JuRCxNQUFBQSxVQUFVLEdBQUksR0FBRUEsVUFBVyxHQUEzQjtBQUNEOztBQUNELFdBQU8sS0FBS3FELFdBQUwsV0FDR2QsaUJBQWlCLENBQUMsS0FBS2UsSUFBTCxDQUFVdkUsTUFBWCxFQUFtQmlCLFVBQW5CLEVBQStCLEtBQS9CLENBRHBCLFNBRUdpRCxrQkFBa0IsQ0FBQyxLQUFLSyxJQUFMLENBQVV2RSxNQUFYLEVBQW1CaUIsVUFBbkIsRUFBK0IsS0FBL0IsQ0FGNUI7QUFHRCxHQVBEOztBQUFBO0FBQUE7QUFBQTtBQUFBOztlQVVlN0IsUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBzeXN0ZW0sIGZzLCB0ZW1wRGlyLCBta2RpcnAsIHppcCB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgaW9zQ29tbWFuZHMgfSBmcm9tICdhcHBpdW0taW9zLWRyaXZlcic7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IGFkZE1lZGlhLCBnZXRBcHBDb250YWluZXIgfSBmcm9tICdub2RlLXNpbWN0bCc7XG5cbmNvbnN0IENPTlRBSU5FUl9QQVRIX01BUktFUiA9ICdAJztcbi8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvUExkQjBHLzJcbmNvbnN0IENPTlRBSU5FUl9QQVRIX1BBVFRFUk4gPSBuZXcgUmVnRXhwKGBeJHtDT05UQUlORVJfUEFUSF9NQVJLRVJ9KFteL10rKS8oLispYCk7XG5jb25zdCBDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IgPSAnOic7XG5cblxubGV0IGNvbW1hbmRzID0gaW9zQ29tbWFuZHMuZmlsZTtcblxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5SUZ1c2VQcmVzZW5jZSAoKSB7XG4gIGlmICghYXdhaXQgZnMud2hpY2goJ2lmdXNlJykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgJ2lmdXNlJyB0b29sIGlzIHJlcXVpcmVkIHRvIGJlIGluc3RhbGxlZCBvbiB0aGUgbWFjaGluZS4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYEluc3RhbGwgaXQgdXNpbmcgJ2JyZXcgY2FzayBpbnN0YWxsIG9zeGZ1c2UgJiYgYnJldyBpbnN0YWxsIGlmdXNlJyBvciBjaGVjayBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgaWYgaXQgaXMgYXZhaWxhYmxlIGluIFBBVEggZW52aXJvbm1lbnQgdmFyaWFibGUgaWYgdGhlIHRvb2wgaXMgYWxyZWFkeSBpbnN0YWxsZWQuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBDdXJyZW50IFBBVEggdmFsdWU6ICR7cHJvY2Vzcy5lbnYuUEFUSH1gKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBtb3VudERldmljZSAoZGV2aWNlLCBpRnVzZUFyZ3MpIHtcbiAgbG9nLmRlYnVnKGBTdGFydGluZyBpZnVzZSB3aXRoIGFyZ3MgJyR7aUZ1c2VBcmdzfScuLi5gKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKCdpZnVzZScsIGlGdXNlQXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ2Fubm90IG1vdW50IHRoZSBtZWRpYSBmb2xkZXIgb2YgdGhlIGRldmljZSB3aXRoIFVESUQgJHtkZXZpY2UudWRpZH0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBNYWtlIHN1cmUgb3N4ZnVzZSBwbHVnaW4gaGFzIG5lY2Vzc2FyeSBwZXJtaXNzaW9ucyBpbiBTeXN0ZW0gUHJlZmVyZW5jZXMtPlNlY3VyaXR5ICYgUHJpdmFjeS4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYEVycm9yIGNvZGU6ICR7ZS5jb2RlfTsgc3RkZXJyIG91dHB1dDogJHtlLnN0ZGVycn1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2ZXJpZnlJc1N1YlBhdGggKG9yaWdpbmFsUGF0aCwgcm9vdCkge1xuICBjb25zdCBub3JtYWxpemVkUm9vdCA9IHBhdGgubm9ybWFsaXplKHJvb3QpO1xuICBjb25zdCBub3JtYWxpemVkUGF0aCA9IHBhdGgubm9ybWFsaXplKHBhdGguZGlybmFtZShvcmlnaW5hbFBhdGgpKTtcbiAgaWYgKCFub3JtYWxpemVkUGF0aC5zdGFydHNXaXRoKG5vcm1hbGl6ZWRSb290KSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGAnJHtub3JtYWxpemVkUGF0aH0nIGlzIGV4cGVjdGVkIHRvIGJlIGEgc3VicGF0aCBvZiAnJHtub3JtYWxpemVkUm9vdH0nYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGFjdHVhbCBwYXRoIGFuZCB0aGUgYnVuZGxlIGlkZW50aWZpZXIgZnJvbSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBnaXZlbiBwYXRoIHN0cmluZy4gVGhlIHN0cmluZyBzaG91bGRcbiAqIG1hdGNoIGBDT05UQUlORVJfUEFUSF9QQVRURVJOYCByZWdleHAsIG90aGVyd2lzZSBhbiBlcnJvciBpcyBnb2luZ1xuICogdG8gYmUgdGhyb3duLiBBIHZhbGlkIHN0cmluZyBleGFtcGxlOiBgQGJ1bmRsZS5pZGVudGlmaWVyOmNvbnRhaW5lcl90eXBlL3JlbGF0aXZlX3BhdGhfaW5fY29udGFpbmVyYFxuICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGNvbnRhaW5lclJvb3RTdXBwbGllciAtIEVpdGhlciBhIHN0cmluZywgdGhhdCBjb250YWluc1xuICogZnVsbCBwYXRoIHRvIHRoZSBtb3VudCByb290IGZvciByZWFsIGRldmljZXMgb3IgYSBmdW5jdGlvbiwgd2hpY2ggYWNjZXB0cyB0d28gcGFyYW1ldGVyc1xuICogKGJ1bmRsZSBpZGVudGlmaWVyIGFuZCBvcHRpb25hbCBjb250YWluZXIgdHlwZSkgYW5kIHJldHVybnMgZnVsbCBwYXRoIHRvIGNvbnRhaW5lclxuICogcm9vdCBmb2xkZXIgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLCBmb3IgU2ltdWxhdG9yXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gLSBBbiBhcnJheSB3aGVyZSB0aGUgZmlyc3QgaXRlbSBpcyB0aGUgcGFyc2VkIGJ1bmRsZVxuICogaWRlbnRpZmllciBhbmQgdGhlIHNlY29uZCBvbmUgaXMgdGhlIGFic29sdXRlIGZ1bGwgcGF0aCBvZiB0aGUgaXRlbSBvbiB0aGUgbG9jYWxcbiAqIGZpbGUgc3lzdGVtXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQ29udGFpbmVyUGF0aCAocmVtb3RlUGF0aCwgY29udGFpbmVyUm9vdFN1cHBsaWVyKSB7XG4gIGNvbnN0IG1hdGNoID0gQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi5leGVjKHJlbW90ZVBhdGgpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEl0IGlzIGV4cGVjdGVkIHRoYXQgcGFja2FnZSBpZGVudGlmaWVyIGAgK1xuICAgICAgYHN0YXJ0cyB3aXRoICcke0NPTlRBSU5FUl9QQVRIX01BUktFUn0nIGFuZCBpcyBzZXBhcmF0ZWQgZnJvbSB0aGUgYCArXG4gICAgICBgcmVsYXRpdmUgcGF0aCB3aXRoIGEgc2luZ2xlIHNsYXNoLiAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIGxldCBbLCBidW5kbGVJZCwgcmVsYXRpdmVQYXRoXSA9IG1hdGNoO1xuICBsZXQgY29udGFpbmVyVHlwZSA9IG51bGw7XG4gIGNvbnN0IHR5cGVTZXBhcmF0b3JQb3MgPSBidW5kbGVJZC5pbmRleE9mKENPTlRBSU5FUl9UWVBFX1NFUEFSQVRPUik7XG4gIC8vIFdlIG9ubHkgY29uc2lkZXIgY29udGFpbmVyIHR5cGUgZXhpc3RzIGlmIGl0cyBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgLy8gbm90IGNvdW50aW5nIHRoZSBjb2xvblxuICBpZiAodHlwZVNlcGFyYXRvclBvcyA+IDAgJiYgdHlwZVNlcGFyYXRvclBvcyA8IGJ1bmRsZUlkLmxlbmd0aCAtIDEpIHtcbiAgICBjb250YWluZXJUeXBlID0gYnVuZGxlSWQuc3Vic3RyaW5nKHR5cGVTZXBhcmF0b3JQb3MgKyAxKTtcbiAgICBsb2cuZGVidWcoYFBhcnNlZCBjb250YWluZXIgdHlwZTogJHtjb250YWluZXJUeXBlfWApO1xuICAgIGJ1bmRsZUlkID0gYnVuZGxlSWQuc3Vic3RyaW5nKDAsIHR5cGVTZXBhcmF0b3JQb3MpO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5lclJvb3QgPSBfLmlzRnVuY3Rpb24oY29udGFpbmVyUm9vdFN1cHBsaWVyKVxuICAgID8gYXdhaXQgY29udGFpbmVyUm9vdFN1cHBsaWVyKGJ1bmRsZUlkLCBjb250YWluZXJUeXBlKVxuICAgIDogY29udGFpbmVyUm9vdFN1cHBsaWVyO1xuICBjb25zdCByZXN1bHRQYXRoID0gcGF0aC5wb3NpeC5yZXNvbHZlKGNvbnRhaW5lclJvb3QsIHJlbGF0aXZlUGF0aCk7XG4gIHZlcmlmeUlzU3ViUGF0aChyZXN1bHRQYXRoLCBjb250YWluZXJSb290KTtcbiAgcmV0dXJuIFtidW5kbGVJZCwgcmVzdWx0UGF0aF07XG59XG5cbi8qKlxuICogU2F2ZSB0aGUgZ2l2ZW4gYmFzZTY0IGRhdGEgY2h1bmsgYXMgYSBiaW5hcnkgZmlsZSBvbiB0aGUgU2ltdWxhdG9yIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRldmljZSAtIFRoZSBkZXZpY2Ugb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBgdWRpZGAgcHJvcGVydHkgY29udGFpbmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCBkZXZpY2UgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCBvbiB0aGUgZGV2aWNlLiBUaGlzIHZhcmlhYmxlIGNhbiBiZSBwcmVmaXhlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bmRsZSBpZCwgc28gdGhlbiB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkIHRvIHRoZSBjb3JyZXNwb25kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG1lZGlhIGZvbGRlciwgZm9yIGV4YW1wbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Bjb20ubXlhcHAuYmxhOmRhdGEvUmVsYXRpdmVQYXRoSW5Db250YWluZXIvMTExLnBuZycuIFRoZSAnQCcgY2hhcmFjdGVyIGF0IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbm5pbmcgb2YgdGhlIGFyZ3VtZW50IGlzIG1hbmRhdG9yeSBpbiBzdWNoIGNhc2UuIFRoZSBjb2xvbiBhdCB0aGUgZW5kIG9mIGJ1bmRsZSBpZGVudGlmaWVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIG9wdGlvbmFsIGFuZCBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIHRoZSBjb250YWluZXIgdHlwZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zc2libGUgdmFsdWVzIHRoZXJlIGFyZSAnYXBwJywgJ2RhdGEnLCAnZ3JvdXBzJywgJzxBIHNwZWNpZmljIEFwcCBHcm91cCBjb250YWluZXI+Jy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgJ2FwcCcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSByZWxhdGl2ZSBmb2xkZXIgcGF0aCBpcyBpZ25vcmVkIGlmIHRoZSBmaWxlIGlzIGdvaW5nIHRvIGJlIHVwbG9hZGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBkZWZhdWx0IG1lZGlhIGZvbGRlciBhbmQgb25seSB0aGUgZmlsZSBuYW1lIGlzIGNvbnNpZGVyZWQgaW1wb3J0YW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NERhdGEgLSBCYXNlLTY0IGVuY29kZWQgY29udGVudCBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVzaEZpbGVUb1NpbXVsYXRvciAoZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJhc2U2NERhdGEsICdiYXNlNjQnKTtcbiAgaWYgKENPTlRBSU5FUl9QQVRIX1BBVFRFUk4udGVzdChyZW1vdGVQYXRoKSkge1xuICAgIGNvbnN0IFtidW5kbGVJZCwgZHN0UGF0aF0gPSBhd2FpdCBwYXJzZUNvbnRhaW5lclBhdGgocmVtb3RlUGF0aCxcbiAgICAgIGFzeW5jIChhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpID0+IGF3YWl0IGdldEFwcENvbnRhaW5lcihkZXZpY2UudWRpZCwgYXBwQnVuZGxlLCBudWxsLCBjb250YWluZXJUeXBlKSk7XG4gICAgbG9nLmluZm8oYFBhcnNlZCBidW5kbGUgaWRlbnRpZmllciAnJHtidW5kbGVJZH0nIGZyb20gJyR7cmVtb3RlUGF0aH0nLiBgICtcbiAgICAgIGBXaWxsIHB1dCB0aGUgZGF0YSBpbnRvICcke2RzdFBhdGh9J2ApO1xuICAgIGlmICghYXdhaXQgZnMuZXhpc3RzKHBhdGguZGlybmFtZShkc3RQYXRoKSkpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgVGhlIGRlc3RpbmF0aW9uIGZvbGRlciAnJHtwYXRoLmRpcm5hbWUoZHN0UGF0aCl9JyBkb2VzIG5vdCBleGlzdC4gQ3JlYXRpbmcuLi5gKTtcbiAgICAgIGF3YWl0IG1rZGlycChwYXRoLmRpcm5hbWUoZHN0UGF0aCkpO1xuICAgIH1cbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0UGF0aCwgYnVmZmVyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZHN0Rm9sZGVyID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUoZHN0Rm9sZGVyLCBwYXRoLmJhc2VuYW1lKHJlbW90ZVBhdGgpKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0UGF0aCwgYnVmZmVyKTtcbiAgICBhd2FpdCBhZGRNZWRpYShkZXZpY2UudWRpZCwgZHN0UGF0aCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKGRzdEZvbGRlcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTYXZlIHRoZSBnaXZlbiBiYXNlNjQgZGF0YSBjaHVuayBhcyBhIGJpbmFyeSBmaWxlIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqIGlmdXNlL29zeGZ1c2Ugc2hvdWxkIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZCBvbiB0aGUgdGFyZ2V0IG1hY2hpbmUgaW4gb3JkZXJcbiAqIGZvciB0aGlzIGZ1bmN0aW9uIHRvIHdvcmsgcHJvcGVybHkuIFJlYWQgaHR0cHM6Ly9naXRodWIuY29tL2xpYmltb2JpbGVkZXZpY2UvaWZ1c2VcbiAqIGFuZCBodHRwczovL2dpdGh1Yi5jb20vb3N4ZnVzZS9vc3hmdXNlL3dpa2kvRkFRIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRldmljZSAtIFRoZSBkZXZpY2Ugb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBgdWRpZGAgcHJvcGVydHkgY29udGFpbmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCBkZXZpY2UgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCBvbiB0aGUgZGV2aWNlLiBUaGlzIHZhcmlhYmxlIGNhbiBiZSBwcmVmaXhlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bmRsZSBpZCwgc28gdGhlbiB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkIHRvIHRoZSBjb3JyZXNwb25kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG1lZGlhIGZvbGRlciwgZm9yIGV4YW1wbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Bjb20ubXlhcHAuYmxhL1JlbGF0aXZlUGF0aEluQ29udGFpbmVyLzExMS5wbmcnLiBUaGUgJ0AnIGNoYXJhY3RlciBhdCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW5uaW5nIG9mIHRoZSBhcmd1bWVudCBpcyBtYW5kYXRvcnkgaW4gc3VjaCBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NERhdGEgLSBCYXNlLTY0IGVuY29kZWQgY29udGVudCBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVzaEZpbGVUb1JlYWxEZXZpY2UgKGRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSkge1xuICBhd2FpdCB2ZXJpZnlJRnVzZVByZXNlbmNlKCk7XG4gIGNvbnN0IG1udFJvb3QgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgbGV0IGlzVW5tb3VudFN1Y2Nlc3NmdWwgPSB0cnVlO1xuICB0cnkge1xuICAgIGxldCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKG1udFJvb3QsIHJlbW90ZVBhdGgpO1xuICAgIGxldCBpZnVzZUFyZ3MgPSBbJy11JywgZGV2aWNlLnVkaWQsIG1udFJvb3RdO1xuICAgIGlmIChDT05UQUlORVJfUEFUSF9QQVRURVJOLnRlc3QocmVtb3RlUGF0aCkpIHtcbiAgICAgIGNvbnN0IFtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyXSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLCBtbnRSb290KTtcbiAgICAgIGRzdFBhdGggPSBwYXRoSW5Db250YWluZXI7XG4gICAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgICBgV2lsbCBwdXQgdGhlIGRhdGEgaW50byAnJHtkc3RQYXRofSdgKTtcbiAgICAgIGlmdXNlQXJncyA9IFsnLXUnLCBkZXZpY2UudWRpZCwgJy0tY29udGFpbmVyJywgYnVuZGxlSWQsIG1udFJvb3RdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJpZnlJc1N1YlBhdGgoZHN0UGF0aCwgbW50Um9vdCk7XG4gICAgfVxuICAgIGF3YWl0IG1vdW50RGV2aWNlKGRldmljZSwgaWZ1c2VBcmdzKTtcbiAgICBpc1VubW91bnRTdWNjZXNzZnVsID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghYXdhaXQgZnMuZXhpc3RzKHBhdGguZGlybmFtZShkc3RQYXRoKSkpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBUaGUgZGVzdGluYXRpb24gZm9sZGVyICcke3BhdGguZGlybmFtZShkc3RQYXRoKX0nIGRvZXMgbm90IGV4aXN0LiBDcmVhdGluZy4uLmApO1xuICAgICAgICBhd2FpdCBta2RpcnAocGF0aC5kaXJuYW1lKGRzdFBhdGgpKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBCdWZmZXIuZnJvbShiYXNlNjREYXRhLCAnYmFzZTY0JykpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBleGVjKCd1bW91bnQnLCBbbW50Um9vdF0pO1xuICAgICAgaXNVbm1vdW50U3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpc1VubW91bnRTdWNjZXNzZnVsKSB7XG4gICAgICBhd2FpdCBmcy5yaW1yYWYobW50Um9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy53YXJuKGBVbW91bnQgaGFzIGZhaWxlZCwgc28gbm90IHJlbW92aW5nICcke21udFJvb3R9J2ApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29udGVudCBvZiBnaXZlbiBmaWxlIG9yIGZvbGRlciBmcm9tIGlPUyBTaW11bGF0b3IgYW5kIHJldHVybiBpdCBhcyBiYXNlLTY0IGVuY29kZWQgc3RyaW5nLlxuICogRm9sZGVyIGNvbnRlbnQgaXMgcmVjdXJzaXZlbHkgcGFja2VkIGludG8gYSB6aXAgYXJjaGl2ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYSBmaWxlIG9yIGEgZm9sZGVyLCB3aGljaCBleGlzdHMgaW4gdGhlIGNvcnJlc3BvbmRpbmcgYXBwbGljYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyIG9uIFNpbXVsYXRvci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3NzaWJsZSBjb250YWluZXIgdHlwZXMgYXJlICdhcHAnLCAnZGF0YScsICdncm91cHMnLCAnPEEgc3BlY2lmaWMgQXBwIEdyb3VwIGNvbnRhaW5lcj4nLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB0eXBlIGlzICdhcHAnLlxuICogQHBhcmFtIHtib29sZWFufSBpc0ZpbGUgLSBXaGV0aGVyIHRoZSBkZXN0aW5hdGlvbiBpdGVtIGlzIGEgZmlsZSBvciBhIGZvbGRlclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1bGxGcm9tU2ltdWxhdG9yIChkZXZpY2UsIHJlbW90ZVBhdGgsIGlzRmlsZSkge1xuICBsZXQgcGF0aE9uU2VydmVyO1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3QgW2J1bmRsZUlkLCBkc3RQYXRoXSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLFxuICAgICAgYXN5bmMgKGFwcEJ1bmRsZSwgY29udGFpbmVyVHlwZSkgPT4gYXdhaXQgZ2V0QXBwQ29udGFpbmVyKGRldmljZS51ZGlkLCBhcHBCdW5kbGUsIG51bGwsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYFdpbGwgZ2V0IHRoZSBkYXRhIGZyb20gJyR7ZHN0UGF0aH0nYCk7XG4gICAgcGF0aE9uU2VydmVyID0gZHN0UGF0aDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzaW1Sb290ID0gZGV2aWNlLmdldERpcigpO1xuICAgIHBhdGhPblNlcnZlciA9IHBhdGgucG9zaXguam9pbihzaW1Sb290LCByZW1vdGVQYXRoKTtcbiAgICB2ZXJpZnlJc1N1YlBhdGgocGF0aE9uU2VydmVyLCBzaW1Sb290KTtcbiAgICBsb2cuaW5mbyhgR290IHRoZSBmdWxsIGl0ZW0gcGF0aDogJHtwYXRoT25TZXJ2ZXJ9YCk7XG4gIH1cbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aE9uU2VydmVyKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGUgcmVtb3RlICR7aXNGaWxlID8gJ2ZpbGUnIDogJ2ZvbGRlcid9IGF0ICcke3BhdGhPblNlcnZlcn0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cbiAgY29uc3QgYnVmZmVyID0gaXNGaWxlXG4gICAgPyBhd2FpdCBmcy5yZWFkRmlsZShwYXRoT25TZXJ2ZXIpXG4gICAgOiBhd2FpdCB6aXAudG9Jbk1lbW9yeVppcChwYXRoT25TZXJ2ZXIpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IG9mIGdpdmVuIGZpbGUgb3IgZm9sZGVyIGZyb20gdGhlIHJlYWwgZGV2aWNlIHVuZGVyIHRlc3QgYW5kIHJldHVybiBpdCBhcyBiYXNlLTY0IGVuY29kZWQgc3RyaW5nLlxuICogRm9sZGVyIGNvbnRlbnQgaXMgcmVjdXJzaXZlbHkgcGFja2VkIGludG8gYSB6aXAgYXJjaGl2ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYW4gZXhpc3RpbmcgcmVtb3RlIGZpbGUgb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSBkb3dubG9hZGVkIGZyb20gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLCBmb3IgZXhhbXBsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQGNvbS5teWFwcC5ibGEvUmVsYXRpdmVQYXRoSW5Db250YWluZXIvMTExLnBuZycuIFRoZSAnQCcgY2hhcmFjdGVyIGF0IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbm5pbmcgb2YgdGhlIGFyZ3VtZW50IGlzIG1hbmRhdG9yeSBpbiBzdWNoIGNhc2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRmlsZSAtIFdoZXRoZXIgdGhlIGRlc3RpbmF0aW9uIGl0ZW0gaXMgYSBmaWxlIG9yIGEgZm9sZGVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSByZW1vdGUgZmlsZVxuICovXG5hc3luYyBmdW5jdGlvbiBwdWxsRnJvbVJlYWxEZXZpY2UgKGRldmljZSwgcmVtb3RlUGF0aCwgaXNGaWxlKSB7XG4gIGF3YWl0IHZlcmlmeUlGdXNlUHJlc2VuY2UoKTtcbiAgY29uc3QgbW50Um9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICBsZXQgaXNVbm1vdW50U3VjY2Vzc2Z1bCA9IHRydWU7XG4gIHRyeSB7XG4gICAgbGV0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUobW50Um9vdCwgcmVtb3RlUGF0aCk7XG4gICAgbGV0IGlmdXNlQXJncyA9IFsnLXUnLCBkZXZpY2UudWRpZCwgbW50Um9vdF07XG4gICAgaWYgKENPTlRBSU5FUl9QQVRIX1BBVFRFUk4udGVzdChyZW1vdGVQYXRoKSkge1xuICAgICAgY29uc3QgW2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXJdID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgsIG1udFJvb3QpO1xuICAgICAgZHN0UGF0aCA9IHBhdGhJbkNvbnRhaW5lcjtcbiAgICAgIGxvZy5pbmZvKGBQYXJzZWQgYnVuZGxlIGlkZW50aWZpZXIgJyR7YnVuZGxlSWR9JyBmcm9tICcke3JlbW90ZVBhdGh9Jy4gYCArXG4gICAgICAgIGBXaWxsIGdldCB0aGUgZGF0YSBmcm9tICcke2RzdFBhdGh9J2ApO1xuICAgICAgaWZ1c2VBcmdzID0gWyctdScsIGRldmljZS51ZGlkLCAnLS1jb250YWluZXInLCBidW5kbGVJZCwgbW50Um9vdF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcmlmeUlzU3ViUGF0aChkc3RQYXRoLCBtbnRSb290KTtcbiAgICB9XG4gICAgYXdhaXQgbW91bnREZXZpY2UoZGV2aWNlLCBpZnVzZUFyZ3MpO1xuICAgIGlzVW5tb3VudFN1Y2Nlc3NmdWwgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFhd2FpdCBmcy5leGlzdHMoZHN0UGF0aCkpIHtcbiAgICAgICAgbG9nLmVycm9yQW5kVGhyb3coYFRoZSByZW1vdGUgJHtpc0ZpbGUgPyAnZmlsZScgOiAnZm9sZGVyJ30gYXQgJyR7ZHN0UGF0aH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXIgPSBpc0ZpbGVcbiAgICAgICAgPyBhd2FpdCBmcy5yZWFkRmlsZShkc3RQYXRoKVxuICAgICAgICA6IGF3YWl0IHppcC50b0luTWVtb3J5WmlwKGRzdFBhdGgpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1ZmZlcikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBleGVjKCd1bW91bnQnLCBbbW50Um9vdF0pO1xuICAgICAgaXNVbm1vdW50U3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpc1VubW91bnRTdWNjZXNzZnVsKSB7XG4gICAgICBhd2FpdCBmcy5yaW1yYWYobW50Um9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy53YXJuKGBVbW91bnQgaGFzIGZhaWxlZCwgc28gbm90IHJlbW92aW5nICcke21udFJvb3R9J2ApO1xuICAgIH1cbiAgfVxufVxuXG5cbmNvbW1hbmRzLnB1c2hGaWxlID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpIHtcbiAgaWYgKHJlbW90ZVBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJdCBpcyBleHBlY3RlZCB0aGF0IHJlbW90ZSBwYXRoIHBvaW50cyB0byBhIGZpbGUgYW5kIG5vdCB0byBhIGZvbGRlci4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCcke3JlbW90ZVBhdGh9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgaWYgKF8uaXNBcnJheShiYXNlNjREYXRhKSkge1xuICAgIC8vIHNvbWUgY2xpZW50cyAoYWhlbSkgamF2YSwgc2VuZCBhIGJ5dGUgYXJyYXkgZW5jb2RpbmcgdXRmOCBjaGFyYWN0ZXJzXG4gICAgLy8gaW5zdGVhZCBvZiBhIHN0cmluZywgd2hpY2ggd291bGQgYmUgaW5maW5pdGVseSBiZXR0ZXIhXG4gICAgYmFzZTY0RGF0YSA9IEJ1ZmZlci5mcm9tKGJhc2U2NERhdGEpLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaXNTaW11bGF0b3IoKVxuICAgID8gYXdhaXQgcHVzaEZpbGVUb1NpbXVsYXRvcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKVxuICAgIDogYXdhaXQgcHVzaEZpbGVUb1JlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSk7XG59O1xuXG5jb21tYW5kcy5wdWxsRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChyZW1vdGVQYXRoKSB7XG4gIGlmIChyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCByZW1vdGUgcGF0aCBwb2ludHMgdG8gYSBmaWxlIGFuZCBub3QgdG8gYSBmb2xkZXIuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIHJldHVybiB0aGlzLmlzU2ltdWxhdG9yKClcbiAgICA/IGF3YWl0IHB1bGxGcm9tU2ltdWxhdG9yKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIHRydWUpXG4gICAgOiBhd2FpdCBwdWxsRnJvbVJlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgdHJ1ZSk7XG59O1xuXG5jb21tYW5kcy5nZXRTaW1GaWxlRnVsbFBhdGggPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCkge1xuICBsZXQgYmFzZVBhdGggPSB0aGlzLm9wdHMuZGV2aWNlLmdldERpcigpO1xuICBsZXQgYXBwTmFtZSA9IG51bGw7XG5cbiAgaWYgKHRoaXMub3B0cy5hcHApIHtcbiAgICBsZXQgYXBwTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXCR7cGF0aC5zZXB9KFtcXFxcdy1dK1xcXFwuYXBwKWApO1xuICAgIGxldCBhcHBOYW1lTWF0Y2hlcyA9IGFwcE5hbWVSZWdleC5leGVjKHRoaXMub3B0cy5hcHApO1xuICAgIGlmIChhcHBOYW1lTWF0Y2hlcykge1xuICAgICAgYXBwTmFtZSA9IGFwcE5hbWVNYXRjaGVzWzFdO1xuICAgIH1cbiAgfVxuICAvLyBkZS1hYnNvbHV0aXplIHRoZSBwYXRoXG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBpZiAocmVtb3RlUGF0aC5pbmRleG9mKCc6Ly8nKSA9PT0gMSkge1xuICAgICAgcmVtb3RlUGF0aCA9IHJlbW90ZVBhdGguc2xpY2UoNCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyZW1vdGVQYXRoLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgcmVtb3RlUGF0aCA9IHJlbW90ZVBhdGguc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbW90ZVBhdGguaW5kZXhPZihhcHBOYW1lKSA9PT0gMCkge1xuICAgIGxldCBmaW5kUGF0aCA9IGJhc2VQYXRoO1xuICAgIGlmICh0aGlzLm9wdHMucGxhdGZvcm1WZXJzaW9uID49IDgpIHtcbiAgICAgIC8vIHRoZSAuYXBwIGZpbGUgYXBwZWFycyBpbiAvQ29udGFpbmVycy9EYXRhIGFuZCAvQ29udGFpbmVycy9CdW5kbGUgYm90aC4gV2Ugb25seSB3YW50IC9CdW5kbGVcbiAgICAgIGZpbmRQYXRoID0gcGF0aC5yZXNvbHZlKGJhc2VQYXRoLCAnQ29udGFpbmVycycsICdCdW5kbGUnKTtcbiAgICB9XG4gICAgZmluZFBhdGggPSBmaW5kUGF0aC5yZXBsYWNlKC9cXHMvZywgJ1xcXFwgJyk7XG5cbiAgICBsZXQgeyBzdGRvdXQgfSA9IGF3YWl0IGV4ZWMoJ2ZpbmQnLCBbZmluZFBhdGgsICctbmFtZScsIGFwcE5hbWVdKTtcbiAgICBsZXQgYXBwUm9vdCA9IHN0ZG91dC5yZXBsYWNlKC9cXG4kLywgJycpO1xuICAgIGxldCBzdWJQYXRoID0gcmVtb3RlUGF0aC5zdWJzdHJpbmcoYXBwTmFtZS5sZW5ndGggKyAxKTtcbiAgICBsZXQgZnVsbFBhdGggPSBwYXRoLnJlc29sdmUoYXBwUm9vdCwgc3ViUGF0aCk7XG4gICAgbG9nLmRlYnVnKGBGaW5kaW5nIGFwcC1yZWxhdGl2ZSBmaWxlOiAnJHtmdWxsUGF0aH0nYCk7XG4gICAgcmV0dXJuIGZ1bGxQYXRoO1xuICB9IGVsc2Uge1xuICAgIGxldCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZShiYXNlUGF0aCwgcmVtb3RlUGF0aCk7XG4gICAgbG9nLmRlYnVnKGBGaW5kaW5nIHNpbS1yZWxhdGl2ZSBmaWxlOiAke2Z1bGxQYXRofWApO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbiAgfVxufTtcblxuY29tbWFuZHMucHVsbEZvbGRlciA9IGFzeW5jIGZ1bmN0aW9uIChyZW1vdGVQYXRoKSB7XG4gIGlmICghcmVtb3RlUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgcmVtb3RlUGF0aCA9IGAke3JlbW90ZVBhdGh9L2A7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaXNTaW11bGF0b3IoKVxuICAgID8gYXdhaXQgcHVsbEZyb21TaW11bGF0b3IodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgZmFsc2UpXG4gICAgOiBhd2FpdCBwdWxsRnJvbVJlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgZmFsc2UpO1xufTtcblxuZXhwb3J0IHsgY29tbWFuZHMgfTtcbmV4cG9ydCBkZWZhdWx0IGNvbW1hbmRzO1xuIl0sImZpbGUiOiJsaWIvY29tbWFuZHMvZmlsZS1tb3ZlbWVudC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
