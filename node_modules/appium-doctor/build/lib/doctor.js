"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FixSkippedError = exports.DoctorCheck = exports.Doctor = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

require("colors");

var _lodash = _interopRequireDefault(require("lodash"));

var _logger = _interopRequireDefault(require("./logger"));

var _package = require("../../package.json");

class FixSkippedError extends Error {}

exports.FixSkippedError = FixSkippedError;

class DoctorCheck {
  constructor(opts = {}) {
    this.autofix = !!opts.autofix;
  }

  diagnose() {
    throw new Error('Not Implemented!');
  }

  fix() {
    throw new Error('Not Implemented!');
  }

}

exports.DoctorCheck = DoctorCheck;

class Doctor {
  constructor() {
    this.checks = [];
    this.toFix = [];
  }

  register(checks) {
    checks = Array.isArray(checks) ? checks : [checks];
    this.checks = this.checks.concat(checks);
  }

  diagnose() {
    var _this = this;

    return (0, _asyncToGenerator2.default)(function* () {
      _logger.default.info('### Diagnostic starting ###');

      _this.toFix = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _this.checks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          let check = _step.value;
          let res = yield check.diagnose();

          if (res.ok) {
            _logger.default.info(` ${'\u2714'.green} ${res.message}`);
          } else {
            let errorMessage = ` ${'\u2716'.red} ${res.message}`;

            _logger.default.warn(errorMessage);

            _this.toFix.push({
              error: errorMessage,
              check
            });
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      let fixMessage;

      switch (_this.toFix.length) {
        case 0:
          fixMessage = 'no fix needed';
          break;

        case 1:
          fixMessage = 'one fix needed';
          break;

        default:
          fixMessage = `${_this.toFix.length} fixes needed`;
      }

      _logger.default.info(`### Diagnostic completed, ${fixMessage}. ###`);

      _logger.default.info('');
    })();
  }

  reportSuccess() {
    var _this2 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      if (_this2.toFix.length === 0) {
        _logger.default.info('Everything looks good, bye!');

        _logger.default.info('');

        return true;
      } else {
        return false;
      }
    })();
  }

  reportManualFixes() {
    var _this3 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      let manualFixes = _lodash.default.filter(_this3.toFix, f => {
        return !f.check.autofix;
      });

      if (manualFixes.length > 0) {
        _logger.default.info('### Manual Fixes Needed ###');

        _logger.default.info('The configuration cannot be automatically fixed, please do the following first:');

        let fixMessages = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = manualFixes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            let f = _step2.value;
            fixMessages.push((yield f.check.fix()));
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _lodash.default.uniq(fixMessages)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            let m = _step3.value;

            _logger.default.warn(`- ${m}`);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        _logger.default.info('###');

        _logger.default.info('');

        _logger.default.info('Bye! Run appium-doctor again when all manual fixes have been applied!');

        _logger.default.info('');

        return true;
      } else {
        return false;
      }
    })();
  }

  runAutoFix(f) {
    return (0, _asyncToGenerator2.default)(function* () {
      _logger.default.info(`### Fixing: ${f.error} ###`);

      try {
        yield f.check.fix();
      } catch (err) {
        if (err instanceof FixSkippedError) {
          _logger.default.info(`### Skipped fix ###`);

          return;
        } else {
          _logger.default.warn(`${err}`.replace(/\n$/g, ''));

          _logger.default.info(`### Fix did not succeed ###`);

          return;
        }
      }

      _logger.default.info('Checking if this was fixed:');

      let res = yield f.check.diagnose();

      if (res.ok) {
        f.fixed = true;

        _logger.default.info(` ${'\u2714'.green} ${res.message}`);

        _logger.default.info(`### Fix was successfully applied ###`);
      } else {
        _logger.default.info(` ${'\u2716'.red} ${res.message}`);

        _logger.default.info(`### Fix was applied but issue remains ###`);
      }
    })();
  }

  runAutoFixes() {
    var _this4 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      let autoFixes = _lodash.default.filter(_this4.toFix, f => {
        return f.check.autofix;
      });

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = autoFixes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          let f = _step4.value;
          yield _this4.runAutoFix(f);

          _logger.default.info('');
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      if (_lodash.default.find(autoFixes, f => {
        return !f.fixed;
      })) {
        _logger.default.info('Bye! A few issues remain, fix manually and/or rerun appium-doctor!');
      } else {
        _logger.default.info('Bye! All issues have been fixed!');
      }

      _logger.default.info('');
    })();
  }

  run() {
    var _this5 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      _logger.default.info(`Appium Doctor v.${_package.version}`);

      yield _this5.diagnose();

      if (yield _this5.reportSuccess()) {
        return;
      }

      if (yield _this5.reportManualFixes()) {
        return;
      }

      yield _this5.runAutoFixes();
    })();
  }

}

exports.Doctor = Doctor;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kb2N0b3IuanMiXSwibmFtZXMiOlsiRml4U2tpcHBlZEVycm9yIiwiRXJyb3IiLCJEb2N0b3JDaGVjayIsImNvbnN0cnVjdG9yIiwib3B0cyIsImF1dG9maXgiLCJkaWFnbm9zZSIsImZpeCIsIkRvY3RvciIsImNoZWNrcyIsInRvRml4IiwicmVnaXN0ZXIiLCJBcnJheSIsImlzQXJyYXkiLCJjb25jYXQiLCJsb2ciLCJpbmZvIiwiY2hlY2siLCJyZXMiLCJvayIsImdyZWVuIiwibWVzc2FnZSIsImVycm9yTWVzc2FnZSIsInJlZCIsIndhcm4iLCJwdXNoIiwiZXJyb3IiLCJmaXhNZXNzYWdlIiwibGVuZ3RoIiwicmVwb3J0U3VjY2VzcyIsInJlcG9ydE1hbnVhbEZpeGVzIiwibWFudWFsRml4ZXMiLCJfIiwiZmlsdGVyIiwiZiIsImZpeE1lc3NhZ2VzIiwidW5pcSIsIm0iLCJydW5BdXRvRml4IiwiZXJyIiwicmVwbGFjZSIsImZpeGVkIiwicnVuQXV0b0ZpeGVzIiwiYXV0b0ZpeGVzIiwiZmluZCIsInJ1biIsInZlcnNpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0EsTUFBTUEsZUFBTixTQUE4QkMsS0FBOUIsQ0FBb0M7Ozs7QUFHcEMsTUFBTUMsV0FBTixDQUFrQjtBQUNoQkMsRUFBQUEsV0FBVyxDQUFFQyxJQUFJLEdBQUcsRUFBVCxFQUFhO0FBQ3RCLFNBQUtDLE9BQUwsR0FBZSxDQUFDLENBQUNELElBQUksQ0FBQ0MsT0FBdEI7QUFDRDs7QUFFREMsRUFBQUEsUUFBUSxHQUFJO0FBQUUsVUFBTSxJQUFJTCxLQUFKLENBQVUsa0JBQVYsQ0FBTjtBQUFzQzs7QUFFcERNLEVBQUFBLEdBQUcsR0FBSTtBQUVMLFVBQU0sSUFBSU4sS0FBSixDQUFVLGtCQUFWLENBQU47QUFDRDs7QUFWZTs7OztBQWFsQixNQUFNTyxNQUFOLENBQWE7QUFDWEwsRUFBQUEsV0FBVyxHQUFJO0FBQ2IsU0FBS00s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VDtBQUNELE9BSEQsTUFHTztBQUVMRCx3QkFBSUMsSUFBSixDQUFTLGtDQUFUO0FBQ0Q7O0FBQ0RELHNCQUFJQyxJQUFKLENBQVMsRUFBVDtBQWJvQjtBQWNyQjs7QUFFSzZCLEVBQUFBLEdBQU4sR0FBYTtBQUFBOztBQUFBO0FBQ1g5QixzQkFBSUMsSUFBSixDQUFVLG1CQUFrQjhCLGdCQUFRLEVBQXBDOztBQUNBLFlBQU0sTUFBSSxDQUFDeEMsUUFBTCxFQUFOOztBQUNBLGdCQUFVLE1BQUksQ0FBQ3VCLGFBQUwsRUFBVixFQUFnQztBQUM5QjtBQUNEOztBQUNELGdCQUFVLE1BQUksQ0FBQ0MsaUJBQUwsRUFBVixFQUFvQztBQUNsQztBQUNEOztBQUNELFlBQU0sTUFBSSxDQUFDWSxZQUFMLEVBQU47QUFUVztBQVVaOztBQS9IVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnY29sb3JzJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5cblxuY2xhc3MgRml4U2tpcHBlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG5jbGFzcyBEb2N0b3JDaGVjayB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICB0aGlzLmF1dG9maXggPSAhIW9wdHMuYXV0b2ZpeDtcbiAgfVxuXG4gIGRpYWdub3NlICgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQhJyk7IH1cblxuICBmaXggKCkge1xuICAgIC8vIHJldHVybiBzdHJpbmcgZm9yIG1hbnVhbCBmaXhlcy5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCEnKTtcbiAgfVxufVxuXG5jbGFzcyBEb2N0b3Ige1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5jaGVja3MgPSBbXTtcbiAgICB0aGlzLnRvRml4ID0gW107XG4gIH1cblxuICByZWdpc3RlciAoY2hlY2tzKSB7XG4gICAgY2hlY2tzID0gQXJyYXkuaXNBcnJheShjaGVja3MpID8gY2hlY2tzIDogW2NoZWNrc107XG4gICAgdGhpcy5jaGVja3MgPSB0aGlzLmNoZWNrcy5jb25jYXQoY2hlY2tzKTtcbiAgfVxuXG4gIGFzeW5jIGRpYWdub3NlICgpIHtcbiAgICBsb2cuaW5mbygnIyMjIERpYWdub3N0aWMgc3RhcnRpbmcgIyMjJyk7XG4gICAgdGhpcy50b0ZpeCA9IFtdO1xuICAgIGZvciAobGV0IGNoZWNrIG9mIHRoaXMuY2hlY2tzKSB7XG4gICAgICBsZXQgcmVzID0gYXdhaXQgY2hlY2suZGlhZ25vc2UoKTtcbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgbG9nLmluZm8oYCAkeydcXHUyNzE0Jy5ncmVlbn0gJHtyZXMubWVzc2FnZX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgICR7J1xcdTI3MTYnLnJlZH0gJHtyZXMubWVzc2FnZX1gO1xuICAgICAgICBsb2cud2FybihlcnJvck1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnRvRml4LnB1c2goe1xuICAgICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgY2hlY2tcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmaXhNZXNzYWdlO1xuICAgIHN3aXRjaCAodGhpcy50b0ZpeC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZml4TWVzc2FnZSA9ICdubyBmaXggbmVlZGVkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGZpeE1lc3NhZ2UgPSAnb25lIGZpeCBuZWVkZWQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZpeE1lc3NhZ2UgPSBgJHt0aGlzLnRvRml4Lmxlbmd0aH0gZml4ZXMgbmVlZGVkYDtcbiAgICB9XG4gICAgbG9nLmluZm8oYCMjIyBEaWFnbm9zdGljIGNvbXBsZXRlZCwgJHtmaXhNZXNzYWdlfS4gIyMjYCk7XG4gICAgbG9nLmluZm8oJycpO1xuICB9XG5cbiAgYXN5bmMgcmVwb3J0U3VjY2VzcyAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1hd2FpdFxuICAgIGlmICh0aGlzLnRvRml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nLmluZm8oJ0V2ZXJ5dGhpbmcgbG9va3MgZ29vZCwgYnllIScpO1xuICAgICAgbG9nLmluZm8oJycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZXBvcnRNYW51YWxGaXhlcyAoKSB7XG4gICAgbGV0IG1hbnVhbEZpeGVzID0gXy5maWx0ZXIodGhpcy50b0ZpeCwgKGYpID0+IHtyZXR1cm4gIWYuY2hlY2suYXV0b2ZpeDt9KTtcbiAgICBpZiAobWFudWFsRml4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgbG9nLmluZm8oJyMjIyBNYW51YWwgRml4ZXMgTmVlZGVkICMjIycpO1xuICAgICAgbG9nLmluZm8oJ1RoZSBjb25maWd1cmF0aW9uIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGZpeGVkLCBwbGVhc2UgZG8gdGhlIGZvbGxvd2luZyBmaXJzdDonKTtcbiAgICAgIC8vIGZvciBtYW51YWwgZml4ZXMsIHRoZSBmaXggbWV0aG9kIGFsd2F5cyByZXR1cm4gYSBzdHJpbmdcbiAgICAgIGxldCBmaXhNZXNzYWdlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgZiBvZiBtYW51YWxGaXhlcykge1xuICAgICAgICBmaXhNZXNzYWdlcy5wdXNoKGF3YWl0IGYuY2hlY2suZml4KCkpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgbSBvZiBfLnVuaXEoZml4TWVzc2FnZXMpKSB7XG4gICAgICAgIGxvZy53YXJuKGAtICR7bX1gKTtcbiAgICAgIH1cbiAgICAgIGxvZy5pbmZvKCcjIyMnKTtcbiAgICAgIGxvZy5pbmZvKCcnKTtcbiAgICAgIGxvZy5pbmZvKCdCeWUhIFJ1biBhcHBpdW0tZG9jdG9yIGFnYWluIHdoZW4gYWxsIG1hbnVhbCBmaXhlcyBoYXZlIGJlZW4gYXBwbGllZCEnKTtcbiAgICAgIGxvZy5pbmZvKCcnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcnVuQXV0b0ZpeCAoZikge1xuICAgIGxvZy5pbmZvKGAjIyMgRml4aW5nOiAke2YuZXJyb3J9ICMjI2ApO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBmLmNoZWNrLmZpeCgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEZpeFNraXBwZWRFcnJvcikge1xuICAgICAgICBsb2cuaW5mbyhgIyMjIFNraXBwZWQgZml4ICMjI2ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cud2FybihgJHtlcnJ9YC5yZXBsYWNlKC9cXG4kL2csICcnKSk7XG4gICAgICAgIGxvZy5pbmZvKGAjIyMgRml4IGRpZCBub3Qgc3VjY2VlZCAjIyNgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuaW5mbygnQ2hlY2tpbmcgaWYgdGhpcyB3YXMgZml4ZWQ6Jyk7XG4gICAgbGV0IHJlcyA9IGF3YWl0IGYuY2hlY2suZGlhZ25vc2UoKTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICBmLmZpeGVkID0gdHJ1ZTtcbiAgICAgIGxvZy5pbmZvKGAgJHsnXFx1MjcxNCcuZ3JlZW59ICR7cmVzLm1lc3NhZ2V9YCk7XG4gICAgICBsb2cuaW5mbyhgIyMjIEZpeCB3YXMgc3VjY2Vzc2Z1bGx5IGFwcGxpZWQgIyMjYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5pbmZvKGAgJHsnXFx1MjcxNicucmVkfSAke3Jlcy5tZXNzYWdlfWApO1xuICAgICAgbG9nLmluZm8oYCMjIyBGaXggd2FzIGFwcGxpZWQgYnV0IGlzc3VlIHJlbWFpbnMgIyMjYCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcnVuQXV0b0ZpeGVzICgpIHtcbiAgICBsZXQgYXV0b0ZpeGVzID0gXy5maWx0ZXIodGhpcy50b0ZpeCwgKGYpID0+IHtyZXR1cm4gZi5jaGVjay5hdXRvZml4O30pO1xuICAgIGZvciAobGV0IGYgb2YgYXV0b0ZpeGVzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkF1dG9GaXgoZik7XG4gICAgICBsb2cuaW5mbygnJyk7XG4gICAgfVxuICAgIGlmIChfLmZpbmQoYXV0b0ZpeGVzLCAoZikgPT4geyByZXR1cm4gIWYuZml4ZWQ7IH0pKSB7XG4gICAgICAvLyBhIGZldyBpc3N1ZXMgcmVtYWluLlxuICAgICAgbG9nLmluZm8oJ0J5ZSEgQSBmZXcgaXNzdWVzIHJlbWFpbiwgZml4IG1hbnVhbGx5IGFuZC9vciByZXJ1biBhcHBpdW0tZG9jdG9yIScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3RoaW5nIGxlZnQgdG8gZml4LlxuICAgICAgbG9nLmluZm8oJ0J5ZSEgQWxsIGlzc3VlcyBoYXZlIGJlZW4gZml4ZWQhJyk7XG4gICAgfVxuICAgIGxvZy5pbmZvKCcnKTtcbiAgfVxuXG4gIGFzeW5jIHJ1biAoKSB7XG4gICAgbG9nLmluZm8oYEFwcGl1bSBEb2N0b3Igdi4ke3ZlcnNpb259YCk7XG4gICAgYXdhaXQgdGhpcy5kaWFnbm9zZSgpO1xuICAgIGlmIChhd2FpdCB0aGlzLnJlcG9ydFN1Y2Nlc3MoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXdhaXQgdGhpcy5yZXBvcnRNYW51YWxGaXhlcygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucnVuQXV0b0ZpeGVzKCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgRG9jdG9yLCBEb2N0b3JDaGVjaywgRml4U2tpcHBlZEVycm9yIH07XG4iXSwiZmlsZSI6ImxpYi9kb2N0b3IuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
